# How to Write a Podcast App Using React

In this post we will iteratively create a simple Podcast listening app using React. The main GUI for the app will be AG Grid so you can see how simple it is to get a prototype application up and running, leaning on the React Data Grid to do much of the heavy lifting for us.

We'll build in small increments:

- Create a basic Data Grid
- Load and render an RSS Feed in the Grid
- Add an Audio Control to Play the podcast using a custom cell renderer
- Allow the user to add the Podcast URL
- Adding Sorting, Filtering, including filtering on data not displayed on the grid.

Each increment allows us to expand on our knowledge of AG Grid and with one or two small code changes we can add a lot of value very quickly to the user. Along the way we will see some of the decision processes involved in designing the app, and learn about Controlled and Uncontrolled Components in React.

This is what we will be building:

![v7-podcast-player-2021-09-30_09-12-07](https://blog.ag-grid.com/content/images/2021/09/v7-podcast-player-2021-09-30_09-12-07.png)

## Let's Create a Simple Podcast Listener in React with AG Grid

You can find the source code for this project at:

- https://github.com/ag-grid/react-data-grid

In the `podcast-player` folder.

The root of the `podcast-player` folder has the current version of the app, and you can run it with:

```
npm install
npm start
```

You do need to have [node.js installed](https://nodejs.org/en/download/) as a pre-requisite.

The project contains sub-folders for the different stages listed in this post e.g. folder 'v1' is the code for the 'Version 1' section. To run any of the intermediate versions, `cd` into the subfolder and run `npm install` followed by `npm start`.


### Getting Started

I created the project using [Create React App](https://github.com/facebook/create-react-app).

```shell
npx create-react-app podcast-player
cd podcast-player
```

This creates a bunch of extra files that I won't be using, but I tend not to delete any of these, on the assumption that even if I am prototyping an application, I can go back later and add unit tests.

I'm going to use the community edition of AG Grid and the AG Grid React UI and add those to my projet using `npm install`

```shell
npm install --save ag-grid-community ag-grid-react
```

These are the basic setup instructions that you can find on the [AG Grid React Getting Started Page](https://ag-grid.com/react-data-grid/getting-started/).

## Version 1 - Create a Grid to Render Podcasts

The first iteration of my application is designed to de-risk the technology. I want to make sure that I can:

- create a running application
- which displays a page to the user
- with a React Data Grid
- containing the information I want to display

Building in small increments means that I can identify any issues early and more easily because I haven't added a lot of code to my project.

We'll start by creating all the scaffolding necessary to render a grid, ready to display a Podcast.

I have in mind a Data Grid that shows all the episodes in the grid with the:

- Title
- Date
- Playable MP3


I will amend the `App.js` generated by `create-react-app` so that it renders a `PodcastGrid`, and we'll work on the `PodcastGrid` during through this tutorial.

### Specify the React Data Grid Interface

The temptation at this point could be to directly use the `AgGridReact` component at my `App` level, but I want to create a simple re-usable component that cuts down on the configuration options available.

And this Data Grid is going to be special since it will take an `rssfeed` as a property. To keep things simple, I'm hardcoding the RSS feed.

```javascript
import './App.css';
import {PodcastGrid} from './PodcastGrid';

function App() {
  return (
    <div className="App">
      <h1>Podcast Player</h1>
      <PodcastGrid
        rssfeed = "https://feeds.simplecast.com/tOjNXec5"
        height= "500px"
        width="100%"
      ></PodcastGrid>
    </div>
  );
}

export default App;
```

Because I'm using React, and passing in the feed URL as a property, the `PodcastGrid` will have the responsibility to load the RSS feed and populate the grid.

I'm also choosing to configure the `height` and `width` of the grid via properties.

This code obviously won't work since I haven't created the `PodcastGrid` component yet. But I've specificed what I want the interface of the component to look and act like, so the next step is to implement it.

### Create a React Data Grid Component

I will create a `PodcastGrid.js` file for our React Grid Component which will render podcasts.

Initially this will just be boiler plate code necessary to compile and render a simple grid with test data.

While I know that my Grid will be created with a property for the RSS Feed, I'm going to ignore that technicality at the moment and render the Grid with hard coded data because I don't want to have to code an RSS parser before I've even rendered a Grid on the screen. I'll start simple and incrementally build the application.

I'll start with the basic boiler plate for a React component, just so that everything compiles, and when I run `npm start` at the command line I can see a running application and implementation of the Grid.

The basic React boiler plate for a component is:

- import React and `useState`, I usually import `useEffect` at the same time
- import `AgGridReact` so that I can use AG Grid as my Data Grid
- import some CSS styling for the grid

```javascript
import React, {useEffect, useState} from 'react';
import {AgGridReact} from 'ag-grid-react';

import 'ag-grid-community/dist/styles/ag-grid.css';
import 'ag-grid-community/dist/styles/ag-theme-alpine.css';

export function PodcastGrid(props) {

return (
       <div className="ag-theme-alpine"
            style={{height: props.height, width: props.width}}>   
           <AgGridReact
                >
           </AgGridReact>
       </div>
    )
}

```

At this point my Grid won't display anything, but it should be visible on the screen and I know that I have correctly added AG Grid into my React project.

If anything failed at this point, I would check my React installation, and possibly work through the [AG Grid React Getting Started Documentation](https://www.ag-grid.com/react-data-grid/getting-started/) or [Tutorial Blog Post](https://blog.ag-grid.com/getting-started-with-react-hooks-and-ag-grid-in-5-minutes/).
### Rendering Data on the Grid

The next step of working iteratively for me is to create a grid that will render some data, using the columns that I specified earlier.

- Title
- Date
- Playable MP3

I'm not going to name them like that though, I'm going to show the headings on the grid as:

- Episode Title
- Published
- Episode

In AG Grid, I configure the columns using an array of Column Definition objects.

```javascript
var columnDefs = [
    {
      headerName: 'Episode Title',
      field: 'title',
    },
    {
      headerName: 'Published',
      field: 'pubDate',
    },
    {
      headerName: 'Episode',
      field: 'mp3',
    }
  ];
```

And then add them to the Grid as properties.

```javascript
<AgGridReact
    columnDefs ={columnDefs}
    >
</AgGridReact>
```

At this point my Grid will now have headers, but will still say `[loading...]` because I haven't supplied the Grid with any data to show in the rows.

I'll hard code some data for the rows and `useState` to store the data.

```javascript
const [rowData, setRowData] = useState([
                                {title: "my episode", 
                                pubDate: new Date(), 
                                mp3: "https://mypodcast/episode.mp3"}]);
```

My data uses the `field` names that I added in the `columnDefs` as the names of the properties in my `rowData`.

I've added `pubDate` as a `Date` object to make sure that AG Grid will render the date, the title is just a `String` and my `mp3` is also just a `String` but it represents a `Url`.

I've created data in the format that I expect to receive it when I parse a podcast RSS feed. I'm making sure that my grid can handle the basic data formats that I want to work with as early as I can.

The next thing to do is to add the data into the grid, which I can do by adding a `rowData` property to the Grid.

```javascript
<AgGridReact
    rowData={rowData}
    columnDefs ={columnDefs}
    >
</AgGridReact>
```

My Grid will now show the hard coded `rowData` that I created, and use the column headers that I configured in the `columnDefs`.

If anything went wrong at this point then I'd double check that my `columnDefs` were using the same `field` names as I created as properties in my `rowData`.

The benefit of doing this with hard coded data is that when I dynamically load the data, should something go wrong, then I know it is related to the array of data dyanimically generated, and not my Grid configuration.

The full version of `PodcastGrid`, after following these steps looks like the code below:


```javascript
import React, {useEffect, useState} from 'react';
import {AgGridReact} from 'ag-grid-react';

import 'ag-grid-community/dist/styles/ag-grid.css';
import 'ag-grid-community/dist/styles/ag-theme-alpine.css';

export function PodcastGrid(props) {

    const [rowData, setRowData] = useState([
                                {title: "my episode", 
                                pubDate: new Date(), 
                                mp3: "https://mypodcast/episode.mp3"}]);

    var columnDefs = [
        {
          headerName: 'Episode Title',
          field: 'title',
        },
        {
          headerName: 'Published',
          field: 'pubDate',
        },
        {
          headerName: 'Episode',
          field: 'mp3',
        }
      ];

    return (
       <div className="ag-theme-alpine"
              style={{height: props.height, width: props.width}}>   
           <AgGridReact
                rowData={rowData}
                columnDefs ={columnDefs}
                >
           </AgGridReact>
       </div>
    )
}
```

The next step is to move from hard coded data, to dynamically loading the data from an RSS Feed.

- [version 1 code](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v1)
- [.dev version 1 code](https://github.dev/ag-grid/react-data-grid/tree/main/podcast-player/v1)
- [live deployed version](https://ag-grid.github.io/react-data-grid/podcast-player/v1/index.html)

At this point our player is very simple:

![v1-podcast-player-2021-09-30_09-06-20](https://blog.ag-grid.com/content/images/2021/09/v1-podcast-player-2021-09-30_09-06-20.png)

## Version 2 - Render an RSS feed in AG Grid

The next thing I want to do is load an RSS feed into the grid.

### What is the Podcast RSS Format?

RSS is a standard format to specify syndication data e.g. for a blog, or a podcast. The RSS feed is an XML document.

- https://validator.w3.org/feed/docs/rss2.html

This is a very flexible standard and has been adapted for use with Podcasts, e.g. Google have a page describing the RSS Podcast format:

- https://support.google.com/podcast-publishers/answer/9889544

Apple also provide an RSS specification:

- https://podcasters.apple.com/support/823-podcast-requirements

We can open the RSS feed that we have been using in a browser and it will render the RSS for us.

- https://feeds.simplecast.com/tOjNXec5

This is the RSS feed for the [WebRush podcast](https://webrush.io/). A podcast covering real world experiences using JavaScript and Modern Web Development.

By looking at the podcast feed in the browser we can see that, to fill the Grid, we need to pull out all the `<item>` elements in the RSS feed, and then the `<title>`, `pubDate` and `enclosure` details:

```javascript
<rss>
   <channel>
      <item>
         <title>my episode</title>
         <pubDate>Thu, 16 Sep 2021 10:00:00 +0000</pubDate>
         <enclosure 
             length="20495"
             type="audio/mpeg"
             url="https://mypodcast/episode.mp3" />
      </item>
   </channel>
</rss>   
```

The code snippet above remove most of the data from the RSS feed that we are not interested in to demonstrate the basic structure of a Podcast RSS feed. There are more fields in the data so it is worth reading the specification and looking at the raw feeds. Then you can see data that would be easy to add to the Grid when you experiment with the source code.

### Parsing XML in the Browser with JavaScript

XML often seems painful to work with, and it might be more convenient to look for a JSON feed, but not every podcast offers a JSON feed.

But XML parsing is built in to most browsers, given that HTML is basically XML. We can use the `DOMParser` from the `window` object.

You can read about the [DOMParser in the MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/DOMParser). It provides a `parseFromString` method which will parse a String of XML or HTML and allow us to use normal `querySelector` operations to find the data.

e.g. if I create a `DOMParser`

```javascript
const parser = new window.DOMParser();
```

I can parse an RSS feed, stored in a `String` called `rssfeed`.

```javascript
const data = parser.parseFromString(rssfeed, 'text/xml'))
```

Then use normal DOM search methods to navigate the XML.

I could return all the `item` elements in the RSS feed with.

```javascript
const itemList = data.querySelectorAll('item');
```

And from each of the `item`s in the array, I could retrive the `title` data:

```javascript
const aTitle = itemList[0].querySelector('title').innerHTML;
```

I'm using the `innerHTML` to get the value from the element.

And I can get an attribute using the normal `getAttribute` method.

```javascript
const mp3Url = itemList[0].querySelector('enclosure').getAttribute('url');
```

We don't need a very sophisticated parsing approach to get the data from an RSS Podcast feed.

### Fetching and Parsing RSS Feed Data


I will want to `fetch` the URL, and then parse it:

```javascript
fetch(props.rssfeed)
        .then(response => response.text())
        .then(str => new window.DOMParser().
                parseFromString(str, 'text/xml'))
```

This would then return an object which I can apply `querySelector` to:

```javascript
fetch(props.rssfeed)
        .then(response => response.text())
        .then(str => new window.DOMParser().
              parseFromString(str, 'text/xml'))
        .then(data => {            
            const itemList = data.querySelectorAll('item');
            ...
```

Because I'm using React, I'll wrap all of this in a `useEffect` method which would trigger when the `rssfeed` in the props changes.

```javascript
useEffect(()=>{

  fetch(props.rssfeed)
    ...
},[props.rssfeed]);        
```

During the final `then` of the `fetch` I'll build up an array of objects which matches the test data used earlier and then `setRowData` to add the data to the Grid.

```javascript
const itemList = data.querySelectorAll('item');

const items=[];
itemList.forEach(el => {
    items.push({
    pubDate: new Date(el.querySelector('pubDate').textContent),
    title: el.querySelector('title').innerHTML,
    mp3: el.querySelector('enclosure').getAttribute('url')
    });
});

setRowData(items)
```

That's the basic theory. Now to implement it.

### Rendering RSS Feed in React Data Grid

So I'll remove my test data:

```javascript
    const [rowData, setRowData] = useState([]);
```

The basic steps to loading an RSS Feed into AG Grid are:

- load from an RSS feed,
- parse the feed using `DOMParser`
- find all the `item` elements and store in an array of `itemList`
- iterate over the list to extract the `title`, `pubDate`, and `mp3` url
- then add all the data into an array called `items`
- which I use to `setRowData`

As you can see below:

```javascript
    useEffect(()=>{

      fetch(props.rssfeed)
        .then(response => response.text())
        .then(str => new window.DOMParser().parseFromString(str, 'text/xml'))
        .then(data => {            
            const itemList = data.querySelectorAll('item');

            const items=[];
            itemList.forEach(el => {
                items.push({
                pubDate: new Date(el.querySelector('pubDate').textContent),
                title: el.querySelector('title').innerHTML,
                mp3: el.querySelector('enclosure').getAttribute('url')
                });
            });

            setRowData(items)
        });

    },[props.rssfeed]);
```

This would actually be enough to load the planned data into the Grid.

### Formatting the Grid

And when I do I can see that it would be useful to format the grid columns.

The Episode Title can be quite long so I want to make the text wrap, and format the cell height to allow all of the `title` to render. I can configure this with some additional column definition properties.

```javascript
wrapText: true,
autoHeight: true,
```

I also want the column to be resizable to give the user the option to control the rendering. Again this is a boolean property on the column definition.

```javascript
resizable: true,
```

I think it would be useful to allow the user to sort the grid to find the most recent podcast. I can implement this using a property on the `pubDate` column.

```javascript
sortable: true,
```

And then to control the column sizes, relative to each other, I will use the `flex` property to make both the `title` and `mp3` twice the size of the `date`

```javascript
flex: 2,
```

The full column definitions are below to enable, sizing, resizing, and sorting.

```javascript
var columnDefs = [
    {
      headerName: 'Episode Title',
      field: 'title',
      wrapText: true,
      autoHeight: true,
      flex: 2,
      resizable: true,
    },
    {
      headerName: 'Published',
      field: 'pubDate',
      sortable: true,
    },
    {
      headerName: 'Episode',
      field: 'mp3',
      flex: 2,
    }
  ];
```

At this point I can't play podcasts, I've actually built a very simple RSS Reader which allows sorting by published episode data.


Here's the code for version 2 in `PodcastGrid.js` :

```javascript
import React, {useEffect, useState} from 'react';
import {AgGridReact} from 'ag-grid-react';

import 'ag-grid-community/dist/styles/ag-grid.css';
import 'ag-grid-community/dist/styles/ag-theme-alpine.css';

export function PodcastGrid(props) {

    const [rowData, setRowData] = useState([]);

    useEffect(()=>{

      fetch(props.rssfeed)
                .then(response => response.text())
                .then(str => new window.DOMParser().parseFromString(str, 'text/xml'))
                .then(data => {            
                    const itemList = data.querySelectorAll('item');
            
                    const items=[];
                    itemList.forEach(el => {
                        items.push({
                        pubDate: new Date(el.querySelector('pubDate').textContent),
                        title: el.querySelector('title').innerHTML,
                        mp3: el.querySelector('enclosure').getAttribute('url')
                        });
                    });

                    setRowData(items)
                });

    },[props.rssfeed]);

    var columnDefs = [
        {
          headerName: 'Episode Title',
          field: 'title',
          wrapText: true,
          autoHeight: true,
          flex: 2,
          resizable: true,
        },
        {
          headerName: 'Published',
          field: 'pubDate',
          sortable: true,
        },
        {
          headerName: 'Episode',
          field: 'mp3',
          flex: 2,
        }
      ];

    return (
       <div className="ag-theme-alpine"
            style={{height: props.height, width: props.width}}>   
           <AgGridReact
                rowData={rowData}
                columnDefs ={columnDefs}
                >
           </AgGridReact>
       </div>
    )
};
```

The next step is to support playing the podcast.

- [version 2 code](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v2)
- [.dev version 2 code](https://github.dev/ag-grid/react-data-grid/tree/main/podcast-player/v2)
- [live deployed version 2](https://ag-grid.github.io/react-data-grid/podcast-player/v2/index.html)

We are now displaying the RSS details:

![v2-podcast-player-2021-09-30_09-07-09](https://blog.ag-grid.com/content/images/2021/09/v2-podcast-player-2021-09-30_09-07-09.png)

## Version 3 - Play The Podcast

For Version 3, to allow people to play the podcast audio, I'm going to do this as simply as possible and create a custom cell renderer for the mp3 field.

AG Grid allows us to use full React Components to render cells, but rather than starting there, I will start by adding an inline `cellRenderer` to the `mp3` field.

A `cellRenderer` allows us to create custom HTML that will render in the cell.

So instead of showing the URL text, I will display an HTML5 audio element.

e.g.

```javascript
<audio controls preload="none">
   <source src="https://mypodcast/episode.mp3" type="audio/mpeg" />
</audio>
```

The simplest way to implement this is to use a `cellRenderer` directly in the column definition, and I will provide a little styling to adjust the height and vertical positioning.

```javascript
cellRenderer: ((params)=>`
      <audio controls preload="none"
          style="height:2em; vertical-align: middle;">
          <source src=${params.value} type="audio/mpeg" />
      </audio>`)
```

And I add this `cellRenderer` to the `mp3` column definition.

```javascript
{
    headerName: 'Episode',
    field: 'mp3',
    flex: 2,
    autoHeight: true,
    cellRenderer: ((params)=>`
          <audio controls preload="none"
              style="height:2em; vertical-align: middle;">
              <source src=${params.value} type="audio/mpeg" />
          </audio>`)
}
```

Making the grid now a functional Podcast player.

- [version 3 code](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v3)
- [.dev version 3 code](https://github.dev/ag-grid/react-data-grid/tree/main/podcast-player/v3)
- [live deployed version 3](https://ag-grid.github.io/react-data-grid/podcast-player/v3/index.html)

After adding the audio player:

![v3-podcast-player-2021-09-30_09-07-43](https://blog.ag-grid.com/content/images/2021/09/v3-podcast-player-2021-09-30_09-07-43.png)

## Version 4 - Customising the RSS Feed

The RSS Feed is still hard coded, so the next step is to allow the feed url to be customized.

Once again, I'll do the simplest thing that will work so I'll add a text field with a default value in the `App.js`.

My first step is to 'reactify' the App and have the RSS URL stored as state.

I'll add the necessary React imports:

```javascript
import React, {useState} from 'react';
```

Then set the state to our hardcoded default.

```javascript
const [rssFeed, setRssFeed] = useState("https://feeds.simplecast.com/tOjNXec5");
```

And use the rssFeed state in the JSX to setup the property for the `PodcastGrid`:

```javascript
<PodcastGrid
    rssfeed = {rssFeed}
```

Giving me an `App.js` that looks like this:


```javascript
import './App.css';
import React, {useState} from 'react';
import {PodcastGrid} from './PodcastGrid';

function App() {

  const [rssFeed, setRssFeed] = useState("https://feeds.simplecast.com/tOjNXec5");

  return (
    <div className="App">
      <h1>Podcast Player</h1>
      <PodcastGrid
        rssfeed = {rssFeed}
        height= "500px"
        width="100%"
      ></PodcastGrid>
    </div>
  );
}

export default App;
```

The simplest way I can think of to make this configurable is to add an input field, with a button to trigger loading the feed.

```javascript
<div>
    <label htmlFor="rssFeedUrl">RSS Feed URL:</label>
    <input type="text" id="rssFeedUrl" name="rssFeedUrl"
        width="80%" defaultValue={rssFeed}/>
    <button onClick={handleLoadFeedClick}>Load Feed</button>
</div>
```

Note that I'm using `defaultValue` in the JSX so that once the value has been set by React, the DOM is then allowed to manage it from then on. If I had used `value` then I would have to take control over the change events. By using `defaultValue` I'm doing the simplest thing that will work to add the basic feature.

Also, when working with JSX I have to use `htmlFor` instead of `for` in the `label` element.

And to handle the button click:

```javascript
const handleLoadFeedClick = ()=>{
    const inputRssFeed = document.getElementById("rssFeedUrl").value;
    setRssFeed(inputRssFeed);
}
```

Now I have the ability to:

- type in a Podcast RSS Feed URL
- click a button
- load the feed into a React Data Grid
- play the podcast episode
- sort the feed to order the episodes

Find online:

- [version 4 code](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v4)
- [.dev version 4 code](https://github.dev/ag-grid/react-data-grid/tree/main/podcast-player/v4)
- [live deployed version 4](https://ag-grid.github.io/react-data-grid/podcast-player/v4/index.html)

Now with the ability to add a URL:

![v4-podcast-player](https://blog.ag-grid.com/content/images/2021/09/v4-podcast-player.png)
### Testing Library `App.test.js`

One thing to do at this point is to amend the `App.test.js` class.

A full introduction to the [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) is beyond the scope of this tutorial, but we can keep the default test created by `create-react-app` working.

By default the `create-react-app` creates a single test for the `App.js` component. This is in the `App.test.js` file.

Having changed `App.js` if we run `npm test` we will be told that our project is failing to pass its test.

This is because the default test, checks the header displayed on screen.


```javascript
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

The default test, shown above:

- is called `renders learn react link`.
- renders the `App` component.
- gets the element on the screen which contains the text "learn react".
- asserts that the element (linkElement) is present, and if not, fails the test.

Because I changed the output from the `App.js`, and even though I'm not doing TDD, I can still amend the test to keep the project build working.

I amended the test to be:

```javascript
test('renders the app', () => {
  render(<App />);
  const headerElement = screen.getByText(/Podcast Player/i);
  expect(headerElement).toBeInTheDocument();
});
```

This finds the header title, and asserts that it is in the document.

Admittedly it isn't much of a test, but it keeps the tests running until we are ready to expand them out to cover the application behaviour.

### CORS

This RSS reader will not work with all Podcast feeds.

Cross-Origin Resource Sharing (CORS) has to be configured to allow other sites to `fetch` the data from a browser. Some Podcasts may be on hosting services which do not allow browser based JavaScript to access the feed.

If a feed does not load, then have a look in your browser console and if you see a message like `blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.` then you know that the site has not been configured to allow web sites to pull the RSS feed.

Most Podcast feed based applications are not browser based so they don't encounter this limitation.

I've listed a few of our favourite JavaScript and technical podcast feeds below, so if you want to experiment with the Podcast player application, you don't have to hunt out a bunch of feed URLs.

- WebRush
    - https://feeds.simplecast.com/tOjNXec5
- The Change Log
    - https://changelog.com/podcast/feed
- The Evil Tester Show
    - https://feed.pod.co/the-evil-tester-show
- JS Party
    - https://changelog.com/jsparty/feed
- Founders Talk
    - https://changelog.com/founderstalk/feed

## Version 5 - Searching and Filtering

Having used the app, I realised that I really wanted some sort of searching and filtering functionality to find episodes on a specific topic.

The easiest way to add that quickly is to add a 'filter' to the columns.

### Filter on Title

The `title` is a `String` so I can use an [in-built AG Grid filter](https://www.ag-grid.com/react-data-grid/filtering/) to allow me to text search and filter the data in the title column.

The built in text filter is called `agTextColumnFilter` and I add it to the column definition as a property:

```javascript
filter: `agGridTextFilter`
```

The `title` column definition now looks as follows:

```javascript
var columnDefs = [
    {
      headerName: 'Episode Title',
      field: 'title',
      wrapText: true,
      autoHeight: true,
      flex: 2,
      resizable: true,
      filter: `agGridTextFilter`
    },
```

This provides me with an out of the box searching and filtering capability for the data in the title.

### Filter on Date

Since it is no extra work for me, I'm going to add a [filter to date](https://ag-grid.com/react-data-grid/filter-date/).

There is an inbuilt Date filter in AG Grid, the `agDateColumnFilter` which I can add as a property to the `pubDate` column.

```javascript
{
  headerName: 'Published',
  field: 'pubDate',
  sortable: true,
  filter: 'agDateColumnFilter'
},
```

With this property added, the user now has the ability to search for podcasts for date ranges.


### Text Filter on Description

The titles of podcasts don't contain as much information as the description. It would be useful to allow searching through the description as well.

The easiest way to add that would be to create a description column and then allow filtering on the column.

I iterated through a few experiments before finding one approach I liked.

- display the full description from the RSS feed
- use `cellRenderer` to display description HTML in the cell
- strip HTML tags from RSS feed data
- show a subset of data using a `valueFormatter`
- use a Quick Filter

#### Display the full description from the RSS feed

I added an additional parsing query in the rss `fetch` to create a `description` property.

```javascript
description: el.querySelector('description')
             .textContent
```

And then added a `Description` column to my Data Grid.

While that worked, the problem is that the description can often be rather large and has embedded HTML formatting.

```javascript
{
  headerName: 'Description',
  field: 'description',
  wrapText: true,
  autoHeight: true,
  flex: 2,
  resizable: true,
  filter: `agGridTextFilter`
},
```

The resulting Grid wasn't very aesthetic.

#### Use `cellRenderer` to display HTML in the cell

Since the data that is retreived in the description is HTML, I could render the HTML directly in the table by creating a `cellRenderer`.

By default the cell shows the data values as text. The output from a `cellRenderer` is rendered as HTML.

Adding a `cellRenderer` property causes the cell to render the supplied HTML, but this was often too large and had embedded images.

```javascript
cellRenderer: ((params)=>params.value)
```

#### Strip HTML tags from RSS feed data

My next thought was to strip all the HTML tags out of the description and render the raw text.

I could do that by removing the `cellRenderer` and adding a regex when parsing the description field.

```javascript
descriptionTxt: el.querySelector('description')
                .textContent.replace(/(<([^>]+)>)/gi, ''),
```

This was the best option so far, but still showed too much text in the cell.

#### Show a subset of data using a `valueFormatter`

The filter for the columns operates on the rowData, not the displayed data, so I could still use a column filter and simply cut down on the data displayed to the user.

I could do that by using a `valueFormatter` rather than a `cellRenderer`.

A `valueFormatter` amends the value and returns it as a `String` to display on the grid. The `cellRenderer` returns HTML.

By showing only a trimmed version of the description, the cell in the Data Grid does not get too large, but still gives me the ability to filter on the complete text.

```javascript
valueFormatter: params => params.data.description.length>125 ?
                     params.data.description.substr(0,125) + "..." :
                     params.data.description
```

This would give me a `description` column definition of:

```javascript
{
  headerName: 'Description',
  field: 'description',
  wrapText: true,
  autoHeight: true,
  flex: 2,
  resizable: true,
  filter: `agGridTextFilter`,
  valueFormatter: params => params.data.description.length>125 ?
                         params.data.description.substr(0,125) + "..." :
                         params.data.description
},
```

#### Use a QuickFilter

A quick filter is a filtering mechanism that matches any of the data in the Data Grid's row data. e.g. using `api.setQuickFilter("testing");` would match any row with "testing" in the `title` or `description` field.

The data does not even have to be rendered to the Data Grid itself, it just has to be present in the data. So I could remove the description column and just add an input field to search the contents. That would make the whole grid simpler and the user experience cleaner.

I'll start by removing the `description` from the `columnDefs`, but keeping the description data in the `rowData`, and I'll use the version with the HTML tags stripped because we are using a text search.

```javascript
description: el
    .querySelector('description')
    .textContent.replace(/(<([^>]+)>)/gi, ''),
});
```

##### App.js changes for QuickFilter

I first need to make changes to the `App.js` to add a 'search' input box.

```javascript
<div>
    <label htmlFor="quickfilter">Quick Filter:</label>
    <input type="text" id="quickfilter" name="quickfilter"
           value={quickFilter} onChange={handleFilterChange}/>        
</div>
```

I then need to create the state for `quickFilter` and write a `handleFilterChange` function that will store the state when we change it in the input field.

```javascript
const [quickFilter, setQuickFilter] = useState("");
```

And then write the `handleFilterChange` function.

```javascript
const handleFilterChange = (event)=>{
    setQuickFilter(event.target.value);
}
```

The next step is to pass the quick filter text to the `PodcastGrid` as a new property.

```javascript
<PodcastGrid
    rssfeed = {rssFeed}
    height= "800px"
    width="100%"     
    quickFilter = {quickFilter}   
></PodcastGrid>
```

##### Use QuickFilter API in React Data Grid

The `PodcastGrid` component has not yet needed to use the AG Grid API, everything has been achieved through properties on the Grid or the Column Definitions.

To be able to access the API I need too hook into the Data Grid's `onGridReady` event, and store the API access as state.


I'll create the state variable first:

```javascript
const [gridApi, setGridApi] = useState();
```

Then amend the Grid declartion to hook into the `onGridReady` callback.

```javascript
<AgGridReact
    onGridReady={onGridReady}
    rowData={rowData}
    columnDefs ={columnDefs}
    >
</AgGridReact>
```

The `onGridReady` handler will store a reference to the Grid API:

```javascript
const onGridReady = (params) => {
  setGridApi(params.api);
}
```

Finally, to use the props variable `quickFilter` that has been passed in:

```javascript
useEffect(()=>{
  if(gridApi){
    gridApi.setQuickFilter(props.quickFilter);
  }
}, [gridApi, props.quickFilter])
```

When the `gridApi` has been set, and the property `quickFilter` changes, we will call the `setQuickFilter` method on the API to filter the Grid.

This provides a very dynamic and clean way of identifying podcasts that include certain words in the description.

Find online:

- [version 5 code](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v5)
- [.dev version 5 code](https://github.dev/ag-grid/react-data-grid/tree/main/podcast-player/v5)
- [live deployed version 5](https://ag-grid.github.io/react-data-grid/podcast-player/v5/index.html)

Ability to search and filter podcasts:

![v5-podcast-player](https://blog.ag-grid.com/content/images/2021/09/v5-podcast-player.png)

## Version 6 - Pagination

After using the app I realised that with so many podcast episodes in a feed, having all of the episodes in a single table was useful but I would have preferred the ability to page through them, and I'd like to see a count of all of the podcast episodes that are available in the feed.

Fortunately we can get all of that functionality from a single AG Grid property.

- [pagination](https://www.ag-grid.com/react-data-grid/row-pagination/)

The property applies to the Grid. I can add it in the Grid declaration:

```javascript
<AgGridReact
    onGridReady={onGridReady}
    rowData={rowData}
    columnDefs ={columnDefs}
    pagination={true}
    >
</AgGridReact>
```

This immediately shows me the count of podcast episodes available and makes navigating through the list easier.

I also want to take advantage of another feature of the AG Grid pagination and set the page size, the default page size is 100, and 10 seems better for this app:

```javascript
paginationPageSize={10}
```

Or I could allow the Grid to choose the best page size for the data and the size of the grid:

```javascript
paginationAutoPageSize={true}
```

Again, i've only added a few extra properties to the Data Grid, but have immediately made the application more usable, with minimal development effort.

Find online:

- [version 6 code](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v6)
- [.dev version 6 code](https://github.dev/ag-grid/react-data-grid/tree/main/podcast-player/v6)
- [live deployed version 6](https://ag-grid.github.io/react-data-grid/podcast-player/v6/index.html)

Pagination added:

![v6-podcast-player](https://blog.ag-grid.com/content/images/2021/09/v6-podcast-player.png)
## Version 7 - Podcast List

I think it would be useful to create a list of podcasts that I listen to, so I don't have to type in the URL each time.

Initially this will be a hard coded list, but longer term it would add more benefit to the user if the list was persisted in some way, either in Local Storage or some online mechanism. But since this tutorial is about getting as much value out to the user with as little coding effort as we can, I'll start with a drop down.

My initial thought is to create a drop down and then set the RSS Feed input with the value:

```html
<div>
  <label htmlFor="podcasts">Choose a podcast:</label>
  <select name="podcasts" id="podcasts" onchange={handleChooseAPodcast}>
    <option value="https://feeds.simplecast.com/tOjNXec5">WebRush</option>
    <option value="https://feed.pod.co/the-evil-tester-show">The Evil Tester Show</option>  
  </select>
</div>
```

To do that I will need to change my app from using an [uncontrolled component](https://reactjs.org/docs/uncontrolled-components.html), to a [controlled component](https://reactjs.org/docs/forms.html#controlled-components).

### Editing Input Field Value with React

The current implementation for the RSS Feed input is uncontrolled:

- once loaded the state of the input field is managed by the browser through normal user interaction
- the value in the input field is set using `defaultValue`. This is only available to programmatic control during initial setup.
- we want the drop down selection to change the `value` of the input field
- to do that, we need to write the event handlers to manage the input field state.

I'll create a state for `inputFeedUrl` to distinguish it from the `rssFeed` which is set when the user clicks the `Load Feed` button.

```javascript
const [inputFeedUrl, setInputFeedUrl] = 
        useState("https://feeds.simplecast.com/tOjNXec5");
```

Then change the text input to a controlled component by setting the `value` with the state, rather than the `defaultValue`.

```javascript
<input type="text" id="rssFeedUrl" name="rssFeedUrl"  style={{width:"50%"}} 
        value={inputFeedUrl}/>
```

The input field is now a controlled component and is read only because we haven't added any `onChange` handling.

```javascript
<input type="text" id="rssFeedUrl" name="rssFeedUrl"  style={{width:"50%"}} 
        value={inputFeedUrl}
        onChange={(event)=>setInputFeedUrl(event.target.value)}/>
```

The drop down for Choose a podcast can now use the state handler to set the `inputFeedUrl`.

```javascript
<select name="podcasts" id="podcasts" 
      onChange={(event)=>setInputFeedUrl(event.target.value)}>
```

Now we have an `input` field controlled with React to allow the user to input an RSS Url, and which we can change the value of from a drop down of hard coded feed Urls.

### Loading a Select element option from an Array

It will be easier to maintain the drop down if the values were taken from an array. This would also open up the application to amending the URLs more easily at run time.

```javascript
const [feedUrls, setFeedUrls] = useState(
  [
    {name: "WebRush", url:"https://feeds.simplecast.com/tOjNXec5"},
    {name: "The Evil Tester Show", url:"https://feed.pod.co/the-evil-tester-show"},
  ]
);
```

Because JSX supports arrays we can directly convert this `feedUrls` array into a set of `option` elements.

```javascript
{feedUrls.map((feed) =>
  <option value={feed.url} key={feed.url}>
    {feed.name}</option>)}
```

I add a `key` property because when creating JSX components from an array, React uses the `key` property to help determine which parts of the HTML need to be re-rendered.


The final thing to do is to set the selected value in the options based on the `inputFeedUrl`.

if I was using JavaScript directly then I would set the `selected` attribute on the option.

```javascript
{feedUrls.map((feed) =>
  <option value={feed.url}  key={feed.url}
    selected={feed.url===inputFeedUrl}
  >{feed.name}</option>)}
```

With React and JSX, to set the selected value for a `select` we set the `value` of the `select` element.

```javascript
<select name="podcasts" id="podcasts" value={inputFeedUrl}
      onChange={(event)=>setInputFeedUrl(event.target.value)}>
```

The full JSX for the podcast drop down looks like this:

```javascript
<div>
  <label htmlFor="podcasts">Choose a podcast:</label>
  <select name="podcasts" id="podcasts" value={inputFeedUrl}
        onChange={(event)=>setInputFeedUrl(event.target.value)}>
        {feedUrls.map((feed) =>
          <option value={feed.url} key={feed.url}
          >{feed.name}</option>)}
  </select>
</div>
```

Now it is easier to build up a list of recommended podcasts, which we know have feeds that are CORS compatible:

- [WebRush](https://feeds.simplecast.com/tOjNXec5)
- [The Evil Tester Show](https://feed.pod.co/the-evil-tester-show)
- [The Change log](https://changelog.com/podcast/feed)
- [JS Party](https://changelog.com/jsparty/feed)
- [Founders Talk](https://changelog.com/founderstalk/feed)

I do recommend some other excellent podcasts but they I couldn't find a CORS compatible RSS feed e.g. [JavaScript Jabber](https://devchat.tv/show/javascript-jabber/)

My final `App.js` looks like the following

```javascript
import './App.css';
import React, {useState} from 'react';
import {PodcastGrid} from './PodcastGrid';

function App() {

  const [inputFeedUrl, setInputFeedUrl] = useState("https://feeds.simplecast.com/tOjNXec5");
  const [rssFeed, setRssFeed] = useState("");
  const [quickFilter, setQuickFilter] = useState("");
  const [feedUrls, setFeedUrls] = useState(
            [
              {name: "WebRush", url:"https://feeds.simplecast.com/tOjNXec5"},
              {name: "The Evil Tester Show", url:"https://feed.pod.co/the-evil-tester-show"},
              {name: "The Change log", url:"https://changelog.com/podcast/feed"},
              {name: "JS Party", url: "https://changelog.com/jsparty/feed"},
              {name: "Founders Talk", url:"https://changelog.com/founderstalk/feed"},
            ]
  );

  const handleLoadFeedClick = ()=>{
    const inputRssFeed = document.getElementById("rssFeedUrl").value;
    setRssFeed(inputRssFeed);
  }

  const handleFilterChange = (event)=>{
    setQuickFilter(event.target.value);
  }


  return (
    <div className="App">
      <h1>Podcast Player</h1>
      <div>
        <label htmlFor="podcasts">Choose a podcast:</label>
        <select name="podcasts" id="podcasts" 
              onChange={(event)=>setInputFeedUrl(event.target.value)}>
              {feedUrls.map((feed) =>
                <option value={feed.url}
                  selected={feed.url===inputFeedUrl}
                >{feed.name}</option>)}
        </select>
      </div>
      <div>
        <label htmlFor="rssFeedUrl">RSS Feed URL:</label>
        <input type="text" id="rssFeedUrl" name="rssFeedUrl"  style={{width:"50%"}} 
                value={inputFeedUrl}
                onChange={(event)=>setInputFeedUrl(event.target.value)}/>
        <button onClick={handleLoadFeedClick}>Load Feed</button>
      </div>
      <div>
      <label htmlFor="quickfilter">Quick Filter:</label>
        <input type="text" id="quickfilter" name="quickfilter" style={{width:"30%"}} value={quickFilter}
              onChange={handleFilterChange}/>        
      </div>
      <div>
        <PodcastGrid rssfeed = {rssFeed}
                     height="500px" width="100%"     
                     quickFilter = {quickFilter}   
      ></PodcastGrid>
      </div>
    </div>
  );
}

export default App;

```

Find online:

- [version 7 code](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v7)
- [.dev version 7 code](https://github.dev/ag-grid/react-data-grid/tree/main/podcast-player/v7)
- [live deployed version 7](https://ag-grid.github.io/react-data-grid/podcast-player/v7/index.html)


With a list of podcasts:

![v7-podcast-player-2021-09-30_09-12-07-1](https://blog.ag-grid.com/content/images/2021/09/v7-podcast-player-2021-09-30_09-12-07-1.png)

## Summary

Obviously there is a lot more that we can improve, but... so long as you type in the correct URL, and the URL feed supports CORS access from other sites then, this is a very simple podcast reader.

We saw that AG Grid made it very easy to experiment with different ways of filtering and interacting with the data, and I was able to explore alteratives with minimal development time.

Most of the functionality I was adding to the application was via out of the box Data Grid features configured through properties. When we did need slightly more interactive functionality, the API was easy to get hold of.


What we learned:

- Incremental development using AG Grid.
- Using fetch to populate an AG Grid.
- Using AG Grid in React.
- Adding a cell renderer in the column definitions.
- Parsing RSS and XML using `DOMParser`.
- Impact of Cross-Origin Resource Sharing (CORS) from JavaScript.
- Some top podcasts to listen to.
- Filtering column data.
- Using the AG Grid API in react.
- `quickFilter` operates on all rowData, not just the displayed data.
- Adding pagination and row count to a Data Grid.

To learn more about [AG Grid and the React UI](https://www.ag-grid.com/react-data-grid/getting-started/).

---

## Version 8 - Adding some test code

In the next few sections I will describe the testing code added to the project.
## What is the Testing Library?

The [Testing Library](https://testing-library.com/) is a JavaScript testing library which works with multiple frameworks. It is not specifically a Unit Testing library because it is designed to target user visible interactions and changes, rather that internal object changes.

In the AG Grid Documentation there is [an example of using Enzyme for Unit level testing](https://www.ag-grid.com/react-data-grid/testing/). This uses low level API Access on the grid to allow access to the internals for the AG Grid.

In the examples in this post I use the Testing Library and do not access the AG Grid API. All the testing is performed through DOM interaction and DOM events. This makes the automating more like end to end tests but the difference is that we don't instantiate the full application, instead we instantiate the component or subset of components that we want to test and build 'just enough' DOM to make the components usable.

## How to Run Testing Library Tests with NPM

The [Testing Library](https://testing-library.com/) is added to our project when we use `create-react-app`.

We can run all the tests for our project with:

```shell
npm test
```

I often use the verbose mode:

```shell
npm test -- --verbose
```

Since `create-react-app` creates a default test for each project in `App.test.js`, we may find that our tests are broken as soon as we start development because one of the first things we do is change the heading for our application.

```javascript
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

For this reason, a lot of people immediately delete the `App.test.js` file after creating their application with the `create-react-app` bootstrap.

Instead, if we keep the test up to date with our application then we can gradually add more tests to our project without too much work.

For the Podcast Player application, I amended the default test to read:

```javascript
test('renders the app', () => {
  render(<App />);
  const headerElement = screen.getByText(/Podcast Player/i);
  expect(headerElement).toBeInTheDocument();
});
```

This change doesn't really help me with my development, since it just looks on the page for the existence of some text, but since the text matches my `h1` I have a working test which I can then use to learn more about the Testing Library.

## How to use The Testing Library

The Testing Library is a set of packages to support testing UI components, without requiring a full browser or integrated environment.

It consists of:

- a core [DOM Testing Library](https://testing-library.com/docs/dom-testing-library/intro) used for querying and interacting with the DOM.
- framework libraries, which extend the core to handle the nuances of each framework.
- support libraries e.g. `user-event` which makes it easier to simulate user interaction with the DOM.

I'm using the [React](https://testing-library.com/docs/react-testing-library/intro) library, but [Angular](https://testing-library.com/docs/angular-testing-library/intro) and [Vue](https://testing-library.com/docs/vue-testing-library/intro) are covered amongst others.

The Testing Library does not contain a test runner, but when `create-react-app` is used, [Jest](https://jestjs.io/) is configured as the default test runner.

The default test created by `create-react-app` looks as follows:

```javascript
test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

To pull this apart to explain the main concepts.

- `test` comes from Jest and allows us to write 'tests' and report on pass/failures
- `render` comes from the react wrapper of Testing Library and renders a React component in a virtual DOM, waiting for the initial events to complete.
- `screen` comes from the core Testing Library and is a convenience object which maps to `document.body` and has the query methods provided by Testing Library pre-bound e.g. allowing `screen.getByText("Podcast")`
- `expect` comes from Jest and allows creating assertions with [matchers](https://jestjs.io/docs/expect)
- `toBeInTheDocument` is a matcher from the [jest-dom](https://testing-library.com/docs/ecosystem-jest-dom) library installed when we used `create-react-app`

After using `create-react-app` most of the libraries are installed.

To test the user interactions I also [installed the `user-event` and `dom` libraries](https://testing-library.com/docs/ecosystem-user-event):

```
npm install --save-dev @testing-library/user-event @testing-library/dom
```

Tests are stored in files with `test` in the name, this allows them to be found by Jest when `npm test` is run.

In the example source I created:

- `App.test.js` this contains tests that explore the interaction between form fields and the grid.
- `PodcastGrid.text.js` this contains tests that look at the Grid component in isolation.


## Testing the Grid Component Scope Decisions

Rather than use `AgGridReact` directly in my application I wrap it in a component to make it easier to configure with properties and handle the support methods unique to the rendering of podcasts.

This also allows me to test `PodcastGrid` rather than `AgGridReact`.

One of the decisions we have to make when testing using 3rd party components like AG Grid is the scope of what we will test.

I don't want to write tests to check that AG Grid works. I want to write tests that assert AG Grid renders the expected data, and any cell renderers I have created display the underlying data as I expect.

I don't want to test AG Grid, I want to test the interaction of my code with AG Grid. This fits in with the general philosophy of the Testing Library which focusses on the functionality from the user perspective, rather than the implementation.

## Testing Library Locator Strategies

Because AG Grid is a complex component I have to differ from the recommended approaches put forward by the Testing Library authors regarding locating elements.

Locating elements is a key part of automating any web application or component. We have to 'find' an element before we can interact with it to 'click', get attributes, check the text, etc.

To 'find' an element we have to query the DOM, and the Testing Library provides an [extensive set of queries](https://testing-library.com/docs/queries/about) e.g.

- `getByLabelText`
- `getByRole`
- `getByPlaceholderText`
- `getByText`
- etc.

The [recommendations from the Testing Library authors](https://testing-library.com/docs/dom-testing-library/faq) include:

- [query by 'visible' elements on screen](https://testing-library.com/docs/dom-testing-library/cheatsheet#queries) like text
- prefer to use a `data-testid` attribute to identify elements on the screen

I have a background in GUI and Web Automation using libraries like WebDriver. I tend to avoid locating elements by text because I often have to perform complex synchronisation and I want to have a high degree of control over the elements selected, so I prefer to use CSS Selectors to find elements in the DOM.

The Testing Library suggestions make a lot of sense when dealing with components, and in particular help avoid the Testing Library tests overlap too far into the internal Unit testing. Component testing with Testing Library will usually require less synchronisation because the component will be instantiated in a specific state, and then the visual elements and user focussed parts can be tested.

The main component I am testing is a data grid. A data grid will often render the same values in multiple cells in the grid, which can make querying by visible text difficult.

When dealing with 3rd party libraries that we are extending, we don't have the option of adding `data-testid` attributes into the 3rd party components. As a personal preference I try to avoid adding automation specific attributes into my code, so I would tend to avoid `data-testid` for that reason alone, but with a locator strategy built around CSS Selectors it doesn't really matter.

As a result of all of the above, rather than use the [recommended query methods](https://testing-library.com/docs/queries/about#priority) most of my element locators are built around `querySelector` or `querySelectorAll`.

## Mitigating Risk of DOM Changes

One reason people avoid `querySelector` as a query strategy is that it is vulnerable to DOM changes or, if we are basing the selectors on CSS Styling, that the CSS Styling locators can change independently of the functionality and we may find functional based tests failing due to styling changes.

One mitigation approach for this is to use query selectors like `getByRole`.

The approach I have used is to add an abstraction layer so that our test code does not use the CSS Selectors directly, instead these are contained in an abstraction. The tests may fail if styling names change, but I only have to 'fix' this in one place in the code.

This can be as simple as:

```javascript
const AudioLocator = {
  source: "audio source"
}
```

Where I could assert on an element attribute value with:

```javascript
expect( 
  element.querySelector(AudioLocator.source).
    getAttribute("src")).
        toEqual("https://eviltester.com")
```

One advantage of using CSS Selectors with AG Grid is that it has a 'theme' concept, which means that many of the CSS Selectors remain stable in order to avoid breaking existing styling themes. We are at risk of AG Grid changing between versions, if we use locators which are not used in theme styling.

## Abstraction Layers

Abstraction layers are also useful with complex 3rd party components because they can be shared between projects. For example [Kerry McKeever](https://kerrymckeever.com/) has an [AG Grid abstraction for Cypress](https://kerrymckeever.com/how-to-test-ag-grid-with-cypress/) which can be found on [GitHub](https://github.com/kpmck/cypress-ag-grid).

In the podcast project, the abstraction code is in the `AgGridTestUtils.js` code.

This has custom selector functions to query the DOM and locate elements, e.g.

```javascript
const columnNamed = (cellName)=>{
  return `.ag-cell[col-id="${cellName}"]`
}
```

It also has the code used to synchronise the grid.

AG Grid performs most of its operations asynchronously so we have to synchronise our test execution with the grid, otherwise we may try and access an element before it is ready for interaction.

Most of these are functions which use the Testing Library's generic [`waitFor` function](https://testing-library.com/docs/dom-testing-library/api-async/#waitfor)

```javascript
const waitForGridToBeInTheDOM=()=>{
    return waitFor(() => {
      expect(document.querySelector(".ag-root-wrapper")).toBeInTheDocument();
    });
}
```

Testing Library also has a built in synchronisation method to wait for an element to be removed: `waitForElementToBeRemoved`.


## Mocking Fetch Requests

Because of the way I wrote my `PodcastGrid` component, I have to mock out `fetch` requests when testing the component.

Writing test code is a good way to identify architecture decisions in your code which may not be optimal.

**If a component is hard to automate in a `test` function, then it may be time to rewrite it.**

But... ideally write a `test` function to cover the functionality first, then when you amend the code, you have a something that checks if you made any errors during any refactoring.



## A Test Explored

I'll break down one of the tests for the `PodcastGrid` to make it easier to understand how to automate AG Grid.

```javascript
it("renders user data from a url", async () => {
```

The tests are written to describe the condition being tested as an assertion i.e. the PodcastGrid can render user data from a url.

Then I need to mock out the `fetch` request made by the `PodcastGrid` in a `useEffect` to load the RSS feed.

First I create the data for the RSS feed in the `fakeRSSFeed` constant.

```javascript
    const fakeRSSFeed = 
    `<channel>
        <item>
            <title>Fake Episode</title>
            <pubDate>Thu, 23 Sep 2021 10:00:00 +0000</pubDate>
            <enclosure url="https://eviltester.com"/>
            <description>
            <![CDATA[ <p>Fake Description</p> ]]>
            </description>
        </item>
    </channel>`;
```

Because we are testing at a component level it is very easy to control the data we need for the testing without having to setup any web servers to deploy files.


A standard function of `jest` is used to spy on any `fetch` calls, and instead of issuing an HTTP request, simply return an object that represents the results of having made a `fetch`.

```javascript
    jest.spyOn(window, "fetch").mockImplementation(() =>{
      return Promise.resolve({
        text: () => fakeRSSFeed
      })}
    );
```

Then I render the component being tested in the DOM.

```javascript 
    render(<PodcastGrid 
      rssfeed="https://fakefeed"
      height="500px"
      width="100%"     
      quickFilter=""/>);
```

And with all the setup out of the way, I can then start to automate AG Grid.

The first thing I have to do is wait for the grid to be fully rendered and populated in the DOM.

```
    await AgGridTest.waitForGridToBeInTheDOM();
    await AgGridTest.waitForDataToHaveLoaded();
```

Both of the above synchronisation methods are contained in the `AgGridTestUtils.js` code.

- `waitForGridToBeInTheDOM` waits for the basic grid to be present in the DOM.
- `waitForDataToHaveLoaded` waits until any 'loading' indicator is no longer present.

At this point AG Grid will then be asynchronously populating the grid with data, so if I start to interact with the Grid now, I'll likely get flaky tests that will work sometimes but at other times fail.

So I add an additional level of synchronisation to check that the pagination has rendered as I expect.

```javascript
    await AgGridTest.waitForPagination().
    then((pagination)=>{
      expect(pagination.firstRow).toEqual("1");
      expect(pagination.lastRow).toEqual("1");
      expect(pagination.rowCount).toEqual("1");  
    });
```


At this point I will check that the cell that represents the `mp3` for the podcast episode has been rendered as an HTML audio control and has the URL from the RSS feed.

This code is also wrapped in a synchronisation `waitFor` function because the audio control can be rendered asynchronously.

```javascript
    
    // the audio component may take a little extra time to render so waitFor it
    await waitFor(() => {
       expect( AgGridTest.getFirstRowWithNamedCellValue("title", "Fake Episode").
                querySelector(AgGridTest.columnNamed('mp3')).
                  querySelector(AudioLocator.source).
                      getAttribute("src")).
                        toEqual("https://eviltester.com")
      }
    )
```

Finally we remove the mock and override from the `fetch` function.

```javascript
    // remove the mock to ensure tests are completely isolated
    global.fetch.mockRestore();
  });
```

Some important things to note about the test code are:

- the abstraction code makes it easy to read and see what is happening
- the code is heavy on synchronisation to avoid flaky execution
- failed synchronisation is treated as a test failure
- assertions are based on the external DOM representation, not the internals from the AG Grid API
- it is possible to use Testing Library to handle 3rd party components
- `querySelector` is a very flexible way to work with 3rd party components

Also, these tests are first draft. The more tests that I add to the project, the more abstraction layers I would build up so the code asserting on the audio component mp3 url would move into a 'waitForAudioComponent' abstraction function to make it re-usable and simplify the test.

The components would be automated and checked individually in isolation first, prior to checking the interaction as an application.

## Testing The Component Integration

The components are integrated through the use of the `App` component, which renders:

- a drop down to select an RSS feed
- a text field showing a URL
- a `PodcastGrid` component which renders AG Grid

Most of the functionality for `PodcastGrid` would be tested in isolation. But I still wanted to make sure that when I click a feed from the dropdown, the grid is populated with the RSS feed.

This is not a full integration test because the `App` component will be tested in the DOM in isolation, but this approach demonstrates that it is possible to gradually build up 'integration' coverage without needing to do all the testing on a deployed application.

At this point I extend my use of Testing Library to cover user events.

Testing Library comes with built in [support for low level event firing](https://testing-library.com/docs/dom-testing-library/api-events) which can be useful for testing components in isolation.

When working in a more integrated setting then the [User Event Extension](https://testing-library.com/docs/ecosystem-user-event/) can help offer a more realistic user interaction event sequence e.g. a 'click' event from the `userEvent` will hover over the element, priori to issuing the mouse events.

## Integration Test Annotation

To demonstrate an integration test, I'll annotate one of the tests below.


The test begins with a description of the expectation.

```javascript
it("loads feed into grid when button pressed", async () => {
```

We have to setup mocking of the `fetch` again. In this case I have two RSS feed variables, because I want to make sure that when the drop down is selected, the url is populated in the text field and a call is made for the correct feed, rather than just returning the same RSS Feed regardless of the URL chosen.

```javascript
  jest.spyOn(window, "fetch").mockImplementation((aUrl) =>{

    if(aUrl==="https://feed.pod.co/the-evil-tester-show"){
      return Promise.resolve({text: () => fakeEvilFeed});
    }else{
      return Promise.resolve({text: () => fakeWebrushFeed});
    }
  });
```

We then render the application component.

```javascript
  render(<App />);
```

At this point we can use the recommended Testing Library methods for element location because the HTML is simpler and under our full control with no 3rd party libraries used. It's basically just a `select` drop down and url `input` field.

I can find the drop down using its label text with `getByLabelText` and then the `userEvent` abstraction layer to select a specific option from the drop down with `selectOptions`.

```javascript
  userEvent.selectOptions(screen.getByLabelText("Choose a podcast:"),'The Evil Tester Show');
```

Having selected the drop down, other code will be executed which populates the url and when the `Load Feed` button is clicked the props on the `PodcastGrid` will be updated, causing the grid to re-render and load data into the grid.

```javascript
  const loadButton = screen.getByText("Load Feed");
  userEvent.click(loadButton);
```

Since the grid will load data we need to synchronise on its updating:


```javascript
  await AgGridTest.waitForGridToBeInTheDOM();
  await AgGridTest.waitForDataToHaveLoaded();
```

Because the `PodcastGrid` component has its own set of tests, all I do in the Integration test is the minimal assertion to check that the title of the correct podcast episode is present in the grid.

```javascript
  // wait for first cell to expected data
  await waitFor(() => {
    expect(AgGridTest.getNamedCellsWithValues("title", "Fake Evil Tester Episode").length).toEqual(1);
  });
```  

And finally tidy up and remove the mock fetch.

```javascript
  // remove the mock to ensure tests are completely isolated
  global.fetch.mockRestore();
});
```
## Summary

There are many ways to automate applications which are using AG Grid components. We can use external automating with libraries such as [Selenium WebDriver](https://www.selenium.dev/), [Puppeteer](https://pptr.dev/), [Playwright](https://playwright.dev/) and [Cypress](https://www.cypress.io/) as demonstrated by [Kerry McKeever's AG Grid Cypress Extension](https://github.com/kpmck/cypress-ag-grid).

We can also incorporate tests into our Unit automation, using Testing Library as this example shows, or using Enzyme as this [Enzyme example in AG Grid Documentation](https://www.ag-grid.com/react-data-grid/testing/) demonstrates. The Enzyme example shows the use of the AG Grid API directly offering a tighter interaction with the grid, which might be useful if you are concentrating on complex filtering code.

The Testing Library example here works purely at a DOM level and uses abstraction layers to make the tests readable and maintainable.

If you are interested in Testing Library then you should certainly check out the [Testing Library Web Site](https://testing-library.com/docs/react-testing-library/intro), and might find the [React Testing Recipes](https://reactjs.org/docs/testing-recipes.html) useful.

All the code to support this blog post is available on [Github](https://github.com/ag-grid/react-data-grid) in the [React Data Grid Podcast Project](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player), in particular the [version 8](https://github.com/ag-grid/react-data-grid/tree/main/podcast-player/v8) folder is the version where Testing Library was used.test


## Available Scripts

In each project directory, you can run:

```
npm install
npm start
```

To run the version of the app.

```
npm run build
```

To create the deployable version in the build folder.

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)



## Notes

### Bugs

- https://feed.syntax.fm/rss fails to parse properly. Need some try catch around the XML processing and if no url or enclosure can be found, try the 'link' attribute and see if the is an mp3 file
    - ` {name: "Syntax FM", url:"https://feed.syntax.fm/rss"}`

### FeedReader

If I want to push the FeedReader into a class to give me more options about which fields I render in the grid then I might expand it as follows:

- FeedReader.js

```
class FeedReader {

    constructor(rssurl) {

      this.items = [];
      this.channelTitle = '';
      this.channelUrl = '';
      this.feedIsLoaded=false;
      this.rss_url = rssurl;
    }

    loadFeed(){
        return new Promise((resolve, reject)=>{
            try{
                fetch(this.rss_url)
                .then(response => response.text())
                .then(str => new window.DOMParser().parseFromString(str, 'text/xml'))
                .then(data => {
                    //console.log(data);
                    const channel = data.querySelector('channel');
                    this.channelTitle = channel.querySelector('title').innerHTML;
                    this.channelUrl = channel.querySelector('link').innerHTML;
            
                    const itemList = data.querySelectorAll('item');
            
                    itemList.forEach(el => {
                        //console.log(el.querySelector('description').textContent);
                        console.log(el.querySelector('pubDate').textContent);
                        this.items.push({
                        channelTitle: this.channelTitle,
                        channelUrl: this.channelUrl,
                        id: String(performance.now()) + String(Math.random() * 16),
                        description: el.querySelector('description').textContent,
                        descriptionTxt: el
                            .querySelector('description')
                            .textContent.replace(/(<([^>]+)>)/gi, ''),
                        pubDateStr: el.querySelector('pubDate').textContent,
                        pubDate: new Date(el.querySelector('pubDate').textContent),
                        duration: el.getElementsByTagName('itunes:duration')[0].textContent, // or calculate from enclosure length
                        title: el.querySelector('title').innerHTML,
                        mp3: el.querySelector('enclosure').getAttribute('url'),
                        link: el.querySelector('link')?.innerHTML,
                        image: el
                            .getElementsByTagName('itunes:image')[0]
                            ?.getAttribute('href')
                        });
                    });

                    this.feedIsLoaded = true;
                    resolve(this.items);
                });

            }catch(err){
                reject(err);
            }
            //console.table(this.items);
        });
    }
  
    getData() {
      return this.items;
    }
  
    isFeedReady() {
      return this.feedIsLoaded;
    }
  }

export default FeedReader;  
```

And we might want to experiment with the columndefs in future versions to support more filtering and rendering.

Columndefs

```
    var columnDefs = [
        {
          headerName: 'Title',
          tooltipField: 'title',
          field: 'title',
          wrapText: true,
          autoHeight: true,
//          cellRenderer: 'textAsHtml', // render as HTML
          flex: 2,
          resizable: true,
//          tooltipComponent: 'episodeTooltip',
          filter: 'agTextColumnFilter', // simple built in text filter
          // override quick filter to enable searching of data,
          // not just the cells
          // https://ag-grid.com/javascript-grid/filter-quick/
        //   getQuickFilterText: params => {
        //     return getSearchableText(params.data);
        //   }
        },
        {
          headerName: 'Published',
          field: 'pubDate', // use the date field, not the string
//          valueFormatter: dateFormatter, // use a custom value formatter function for rendering the date
          sortable: true, // allow sorting by date
          filter: 'agDateColumnFilter' // built in date filter
        },
        {
          headerName: 'Episode',
          field: 'mp3',
          flex: 2,
//          cellRenderer: 'audioHTMLRenderer' // render as a custom control
        }
      ];
```


#### Show full description in a Tooltip

Since the `valueFormatter` shows a subset of data, I thought it would be useful to experiment with showing all of the description data, but in a tooltip when the user hovers over the description.

AG Grid has a customisable [Tooltip Component](https://www.ag-grid.com/react-data-grid/component-tooltip/) which we can use to show the data on hover.

The Tooltip component can be normal React component.

- component .jsx
- remember to add the CSS


PodcastDescriptionTooltip.jsx

```
import React, { forwardRef, useImperativeHandle, useState } from 'react';

export default forwardRef((props, ref) => {
    const [data, setData] = useState(props.api.getDisplayedRowAtIndex(props.rowIndex).data);
  
    useImperativeHandle(ref, () => {
        return {
            getReactContainerClasses() {
                return ['custom-tooltip'];
            }
        }
    });
  
    return (        
        <div className="custom-tooltip">
            <p>{data.title}</p>
            <p>{data.description}</p>
        </div>
    );
  });
```

```
import PodcastDescriptionTooltip from './PodcastDescriptionTooltip.jsx'
```

```
          tooltipField:"description",
          tooltipComponent: 'podcastDescriptionTooltip'
```

```
tooltipShowDelay={0}
                frameworkComponents={{ podcastDescriptionTooltip: PodcastDescriptionTooltip }}
```

CSS

```
.custom-tooltip {
  position: absolute;
  overflow: visible;
  pointer-events: none;
  transition: opacity 1;
  background-color: white;
  width: 90%;
  line-height: 1;
  padding: 5px;
  text-align: left;
  text-indent: 0;
}

.custom-tooltip.ag-tooltip-hiding {
  opacity: 0;
}

.custom-tooltip p {
  white-space: normal;
  border: 0px;
  margin: 3px;
  text-indent: 0;
}

.custom-tooltip p:first-of-type {
  font-weight: bold;
}
```
